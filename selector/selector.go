// generated by Textmapper; DO NOT EDIT

package selector

import (
	"github.com/satishbabariya/llts"
)

type Selector func (nt llts.NodeType) bool

var (
	Any = func(t llts.NodeType) bool { return true }
	Abstract = func(t llts.NodeType) bool { return t == llts.Abstract }
	AccessibilityModifier = func(t llts.NodeType) bool { return t == llts.AccessibilityModifier }
	AdditiveExpr = func(t llts.NodeType) bool { return t == llts.AdditiveExpr }
	Arguments = func(t llts.NodeType) bool { return t == llts.Arguments }
	ArrayLiteral = func(t llts.NodeType) bool { return t == llts.ArrayLiteral }
	ArrayPattern = func(t llts.NodeType) bool { return t == llts.ArrayPattern }
	ArrayType = func(t llts.NodeType) bool { return t == llts.ArrayType }
	ArrowFunc = func(t llts.NodeType) bool { return t == llts.ArrowFunc }
	AssertsType = func(t llts.NodeType) bool { return t == llts.AssertsType }
	AssignmentExpr = func(t llts.NodeType) bool { return t == llts.AssignmentExpr }
	AssignmentOperator = func(t llts.NodeType) bool { return t == llts.AssignmentOperator }
	AsyncArrowFunc = func(t llts.NodeType) bool { return t == llts.AsyncArrowFunc }
	AsyncFunc = func(t llts.NodeType) bool { return t == llts.AsyncFunc }
	AsyncFuncExpr = func(t llts.NodeType) bool { return t == llts.AsyncFuncExpr }
	AsyncMethod = func(t llts.NodeType) bool { return t == llts.AsyncMethod }
	AwaitExpr = func(t llts.NodeType) bool { return t == llts.AwaitExpr }
	BindingRestElement = func(t llts.NodeType) bool { return t == llts.BindingRestElement }
	BitwiseAND = func(t llts.NodeType) bool { return t == llts.BitwiseAND }
	BitwiseOR = func(t llts.NodeType) bool { return t == llts.BitwiseOR }
	BitwiseXOR = func(t llts.NodeType) bool { return t == llts.BitwiseXOR }
	Block = func(t llts.NodeType) bool { return t == llts.Block }
	Body = func(t llts.NodeType) bool { return t == llts.Body }
	BreakStmt = func(t llts.NodeType) bool { return t == llts.BreakStmt }
	CallExpr = func(t llts.NodeType) bool { return t == llts.CallExpr }
	CallSignature = func(t llts.NodeType) bool { return t == llts.CallSignature }
	Case = func(t llts.NodeType) bool { return t == llts.Case }
	Catch = func(t llts.NodeType) bool { return t == llts.Catch }
	Class = func(t llts.NodeType) bool { return t == llts.Class }
	ClassBody = func(t llts.NodeType) bool { return t == llts.ClassBody }
	ClassExpr = func(t llts.NodeType) bool { return t == llts.ClassExpr }
	CoalesceExpr = func(t llts.NodeType) bool { return t == llts.CoalesceExpr }
	CommaExpr = func(t llts.NodeType) bool { return t == llts.CommaExpr }
	ComputedPropertyName = func(t llts.NodeType) bool { return t == llts.ComputedPropertyName }
	ConciseBody = func(t llts.NodeType) bool { return t == llts.ConciseBody }
	ConditionalExpr = func(t llts.NodeType) bool { return t == llts.ConditionalExpr }
	ConstructSignature = func(t llts.NodeType) bool { return t == llts.ConstructSignature }
	ConstructorType = func(t llts.NodeType) bool { return t == llts.ConstructorType }
	ContinueStmt = func(t llts.NodeType) bool { return t == llts.ContinueStmt }
	DebuggerStmt = func(t llts.NodeType) bool { return t == llts.DebuggerStmt }
	Declare = func(t llts.NodeType) bool { return t == llts.Declare }
	DecoratorCall = func(t llts.NodeType) bool { return t == llts.DecoratorCall }
	DecoratorExpr = func(t llts.NodeType) bool { return t == llts.DecoratorExpr }
	Default = func(t llts.NodeType) bool { return t == llts.Default }
	DefaultParameter = func(t llts.NodeType) bool { return t == llts.DefaultParameter }
	DoWhileStmt = func(t llts.NodeType) bool { return t == llts.DoWhileStmt }
	ElementBinding = func(t llts.NodeType) bool { return t == llts.ElementBinding }
	EmptyDecl = func(t llts.NodeType) bool { return t == llts.EmptyDecl }
	EmptyStmt = func(t llts.NodeType) bool { return t == llts.EmptyStmt }
	EqualityExpr = func(t llts.NodeType) bool { return t == llts.EqualityExpr }
	ExponentiationExpr = func(t llts.NodeType) bool { return t == llts.ExponentiationExpr }
	ExportClause = func(t llts.NodeType) bool { return t == llts.ExportClause }
	ExportDecl = func(t llts.NodeType) bool { return t == llts.ExportDecl }
	ExportDefault = func(t llts.NodeType) bool { return t == llts.ExportDefault }
	ExportSpec = func(t llts.NodeType) bool { return t == llts.ExportSpec }
	ExprStmt = func(t llts.NodeType) bool { return t == llts.ExprStmt }
	Extends = func(t llts.NodeType) bool { return t == llts.Extends }
	Finally = func(t llts.NodeType) bool { return t == llts.Finally }
	ForBinding = func(t llts.NodeType) bool { return t == llts.ForBinding }
	ForCondition = func(t llts.NodeType) bool { return t == llts.ForCondition }
	ForFinalExpr = func(t llts.NodeType) bool { return t == llts.ForFinalExpr }
	ForInStmt = func(t llts.NodeType) bool { return t == llts.ForInStmt }
	ForInStmtWithVar = func(t llts.NodeType) bool { return t == llts.ForInStmtWithVar }
	ForOfStmt = func(t llts.NodeType) bool { return t == llts.ForOfStmt }
	ForOfStmtWithVar = func(t llts.NodeType) bool { return t == llts.ForOfStmtWithVar }
	ForStmt = func(t llts.NodeType) bool { return t == llts.ForStmt }
	ForStmtWithVar = func(t llts.NodeType) bool { return t == llts.ForStmtWithVar }
	Func = func(t llts.NodeType) bool { return t == llts.Func }
	FuncExpr = func(t llts.NodeType) bool { return t == llts.FuncExpr }
	FuncType = func(t llts.NodeType) bool { return t == llts.FuncType }
	Generator = func(t llts.NodeType) bool { return t == llts.Generator }
	GeneratorExpr = func(t llts.NodeType) bool { return t == llts.GeneratorExpr }
	GeneratorMethod = func(t llts.NodeType) bool { return t == llts.GeneratorMethod }
	Getter = func(t llts.NodeType) bool { return t == llts.Getter }
	IdentExpr = func(t llts.NodeType) bool { return t == llts.IdentExpr }
	IfStmt = func(t llts.NodeType) bool { return t == llts.IfStmt }
	ImportDecl = func(t llts.NodeType) bool { return t == llts.ImportDecl }
	ImportSpec = func(t llts.NodeType) bool { return t == llts.ImportSpec }
	ImportType = func(t llts.NodeType) bool { return t == llts.ImportType }
	InExpr = func(t llts.NodeType) bool { return t == llts.InExpr }
	IndexAccess = func(t llts.NodeType) bool { return t == llts.IndexAccess }
	IndexSignature = func(t llts.NodeType) bool { return t == llts.IndexSignature }
	IndexedAccessType = func(t llts.NodeType) bool { return t == llts.IndexedAccessType }
	Initializer = func(t llts.NodeType) bool { return t == llts.Initializer }
	InstanceOfExpr = func(t llts.NodeType) bool { return t == llts.InstanceOfExpr }
	IntersectionType = func(t llts.NodeType) bool { return t == llts.IntersectionType }
	KeyOfType = func(t llts.NodeType) bool { return t == llts.KeyOfType }
	LabelIdent = func(t llts.NodeType) bool { return t == llts.LabelIdent }
	LabelledStmt = func(t llts.NodeType) bool { return t == llts.LabelledStmt }
	LetOrConst = func(t llts.NodeType) bool { return t == llts.LetOrConst }
	LexicalBinding = func(t llts.NodeType) bool { return t == llts.LexicalBinding }
	LexicalDecl = func(t llts.NodeType) bool { return t == llts.LexicalDecl }
	Literal = func(t llts.NodeType) bool { return t == llts.Literal }
	LiteralPropertyName = func(t llts.NodeType) bool { return t == llts.LiteralPropertyName }
	LiteralType = func(t llts.NodeType) bool { return t == llts.LiteralType }
	LogicalAND = func(t llts.NodeType) bool { return t == llts.LogicalAND }
	LogicalOR = func(t llts.NodeType) bool { return t == llts.LogicalOR }
	MappedType = func(t llts.NodeType) bool { return t == llts.MappedType }
	MemberMethod = func(t llts.NodeType) bool { return t == llts.MemberMethod }
	MemberVar = func(t llts.NodeType) bool { return t == llts.MemberVar }
	Method = func(t llts.NodeType) bool { return t == llts.Method }
	MethodSignature = func(t llts.NodeType) bool { return t == llts.MethodSignature }
	Module = func(t llts.NodeType) bool { return t == llts.Module }
	ModuleSpec = func(t llts.NodeType) bool { return t == llts.ModuleSpec }
	MultiplicativeExpr = func(t llts.NodeType) bool { return t == llts.MultiplicativeExpr }
	NameIdent = func(t llts.NodeType) bool { return t == llts.NameIdent }
	NameSpaceImport = func(t llts.NodeType) bool { return t == llts.NameSpaceImport }
	NamedImports = func(t llts.NodeType) bool { return t == llts.NamedImports }
	NewExpr = func(t llts.NodeType) bool { return t == llts.NewExpr }
	NewTarget = func(t llts.NodeType) bool { return t == llts.NewTarget }
	NoElement = func(t llts.NodeType) bool { return t == llts.NoElement }
	NonNullableType = func(t llts.NodeType) bool { return t == llts.NonNullableType }
	NullableType = func(t llts.NodeType) bool { return t == llts.NullableType }
	ObjectLiteral = func(t llts.NodeType) bool { return t == llts.ObjectLiteral }
	ObjectMethod = func(t llts.NodeType) bool { return t == llts.ObjectMethod }
	ObjectPattern = func(t llts.NodeType) bool { return t == llts.ObjectPattern }
	ObjectType = func(t llts.NodeType) bool { return t == llts.ObjectType }
	OptionalCallExpr = func(t llts.NodeType) bool { return t == llts.OptionalCallExpr }
	OptionalIndexAccess = func(t llts.NodeType) bool { return t == llts.OptionalIndexAccess }
	OptionalPropertyAccess = func(t llts.NodeType) bool { return t == llts.OptionalPropertyAccess }
	Parameters = func(t llts.NodeType) bool { return t == llts.Parameters }
	Parenthesized = func(t llts.NodeType) bool { return t == llts.Parenthesized }
	ParenthesizedType = func(t llts.NodeType) bool { return t == llts.ParenthesizedType }
	PostDec = func(t llts.NodeType) bool { return t == llts.PostDec }
	PostInc = func(t llts.NodeType) bool { return t == llts.PostInc }
	PreDec = func(t llts.NodeType) bool { return t == llts.PreDec }
	PreInc = func(t llts.NodeType) bool { return t == llts.PreInc }
	PredefinedType = func(t llts.NodeType) bool { return t == llts.PredefinedType }
	Property = func(t llts.NodeType) bool { return t == llts.Property }
	PropertyAccess = func(t llts.NodeType) bool { return t == llts.PropertyAccess }
	PropertyBinding = func(t llts.NodeType) bool { return t == llts.PropertyBinding }
	PropertySignature = func(t llts.NodeType) bool { return t == llts.PropertySignature }
	Readonly = func(t llts.NodeType) bool { return t == llts.Readonly }
	ReadonlyType = func(t llts.NodeType) bool { return t == llts.ReadonlyType }
	ReferenceIdent = func(t llts.NodeType) bool { return t == llts.ReferenceIdent }
	RelationalExpr = func(t llts.NodeType) bool { return t == llts.RelationalExpr }
	RestParameter = func(t llts.NodeType) bool { return t == llts.RestParameter }
	RestType = func(t llts.NodeType) bool { return t == llts.RestType }
	ReturnStmt = func(t llts.NodeType) bool { return t == llts.ReturnStmt }
	Setter = func(t llts.NodeType) bool { return t == llts.Setter }
	ShiftExpr = func(t llts.NodeType) bool { return t == llts.ShiftExpr }
	ShorthandProperty = func(t llts.NodeType) bool { return t == llts.ShorthandProperty }
	SingleNameBinding = func(t llts.NodeType) bool { return t == llts.SingleNameBinding }
	SpreadElement = func(t llts.NodeType) bool { return t == llts.SpreadElement }
	SpreadProperty = func(t llts.NodeType) bool { return t == llts.SpreadProperty }
	Static = func(t llts.NodeType) bool { return t == llts.Static }
	SuperExpr = func(t llts.NodeType) bool { return t == llts.SuperExpr }
	SwitchStmt = func(t llts.NodeType) bool { return t == llts.SwitchStmt }
	SyntaxProblem = func(t llts.NodeType) bool { return t == llts.SyntaxProblem }
	This = func(t llts.NodeType) bool { return t == llts.This }
	ThisType = func(t llts.NodeType) bool { return t == llts.ThisType }
	ThrowStmt = func(t llts.NodeType) bool { return t == llts.ThrowStmt }
	TryStmt = func(t llts.NodeType) bool { return t == llts.TryStmt }
	TsAmbientBinding = func(t llts.NodeType) bool { return t == llts.TsAmbientBinding }
	TsAmbientClass = func(t llts.NodeType) bool { return t == llts.TsAmbientClass }
	TsAmbientEnum = func(t llts.NodeType) bool { return t == llts.TsAmbientEnum }
	TsAmbientExportDecl = func(t llts.NodeType) bool { return t == llts.TsAmbientExportDecl }
	TsAmbientFunc = func(t llts.NodeType) bool { return t == llts.TsAmbientFunc }
	TsAmbientGlobal = func(t llts.NodeType) bool { return t == llts.TsAmbientGlobal }
	TsAmbientImportAlias = func(t llts.NodeType) bool { return t == llts.TsAmbientImportAlias }
	TsAmbientInterface = func(t llts.NodeType) bool { return t == llts.TsAmbientInterface }
	TsAmbientModule = func(t llts.NodeType) bool { return t == llts.TsAmbientModule }
	TsAmbientNamespace = func(t llts.NodeType) bool { return t == llts.TsAmbientNamespace }
	TsAmbientTypeAlias = func(t llts.NodeType) bool { return t == llts.TsAmbientTypeAlias }
	TsAmbientVar = func(t llts.NodeType) bool { return t == llts.TsAmbientVar }
	TsAsConstExpr = func(t llts.NodeType) bool { return t == llts.TsAsConstExpr }
	TsAsExpr = func(t llts.NodeType) bool { return t == llts.TsAsExpr }
	TsCastExpr = func(t llts.NodeType) bool { return t == llts.TsCastExpr }
	TsConditional = func(t llts.NodeType) bool { return t == llts.TsConditional }
	TsConst = func(t llts.NodeType) bool { return t == llts.TsConst }
	TsDynamicImport = func(t llts.NodeType) bool { return t == llts.TsDynamicImport }
	TsEnum = func(t llts.NodeType) bool { return t == llts.TsEnum }
	TsEnumBody = func(t llts.NodeType) bool { return t == llts.TsEnumBody }
	TsEnumMember = func(t llts.NodeType) bool { return t == llts.TsEnumMember }
	TsExclToken = func(t llts.NodeType) bool { return t == llts.TsExclToken }
	TsExport = func(t llts.NodeType) bool { return t == llts.TsExport }
	TsExportAssignment = func(t llts.NodeType) bool { return t == llts.TsExportAssignment }
	TsImplementsClause = func(t llts.NodeType) bool { return t == llts.TsImplementsClause }
	TsImportAliasDecl = func(t llts.NodeType) bool { return t == llts.TsImportAliasDecl }
	TsImportRequireDecl = func(t llts.NodeType) bool { return t == llts.TsImportRequireDecl }
	TsIndexMemberDecl = func(t llts.NodeType) bool { return t == llts.TsIndexMemberDecl }
	TsInterface = func(t llts.NodeType) bool { return t == llts.TsInterface }
	TsInterfaceExtends = func(t llts.NodeType) bool { return t == llts.TsInterfaceExtends }
	TsNamespace = func(t llts.NodeType) bool { return t == llts.TsNamespace }
	TsNamespaceBody = func(t llts.NodeType) bool { return t == llts.TsNamespaceBody }
	TsNamespaceExportDecl = func(t llts.NodeType) bool { return t == llts.TsNamespaceExportDecl }
	TsNonNull = func(t llts.NodeType) bool { return t == llts.TsNonNull }
	TsThisParameter = func(t llts.NodeType) bool { return t == llts.TsThisParameter }
	TsTypeOnly = func(t llts.NodeType) bool { return t == llts.TsTypeOnly }
	TupleType = func(t llts.NodeType) bool { return t == llts.TupleType }
	TypeAliasDecl = func(t llts.NodeType) bool { return t == llts.TypeAliasDecl }
	TypeAnnotation = func(t llts.NodeType) bool { return t == llts.TypeAnnotation }
	TypeArguments = func(t llts.NodeType) bool { return t == llts.TypeArguments }
	TypeConstraint = func(t llts.NodeType) bool { return t == llts.TypeConstraint }
	TypeName = func(t llts.NodeType) bool { return t == llts.TypeName }
	TypeParameter = func(t llts.NodeType) bool { return t == llts.TypeParameter }
	TypeParameters = func(t llts.NodeType) bool { return t == llts.TypeParameters }
	TypePredicate = func(t llts.NodeType) bool { return t == llts.TypePredicate }
	TypeQuery = func(t llts.NodeType) bool { return t == llts.TypeQuery }
	TypeReference = func(t llts.NodeType) bool { return t == llts.TypeReference }
	TypeVar = func(t llts.NodeType) bool { return t == llts.TypeVar }
	UnaryExpr = func(t llts.NodeType) bool { return t == llts.UnaryExpr }
	UnionType = func(t llts.NodeType) bool { return t == llts.UnionType }
	UniqueType = func(t llts.NodeType) bool { return t == llts.UniqueType }
	Var = func(t llts.NodeType) bool { return t == llts.Var }
	VarDecl = func(t llts.NodeType) bool { return t == llts.VarDecl }
	VarStmt = func(t llts.NodeType) bool { return t == llts.VarStmt }
	WhileStmt = func(t llts.NodeType) bool { return t == llts.WhileStmt }
	WithStmt = func(t llts.NodeType) bool { return t == llts.WithStmt }
	Yield = func(t llts.NodeType) bool { return t == llts.Yield }
	MultiLineComment = func(t llts.NodeType) bool { return t == llts.MultiLineComment }
	SingleLineComment = func(t llts.NodeType) bool { return t == llts.SingleLineComment }
	InvalidToken = func(t llts.NodeType) bool { return t == llts.InvalidToken }
	BindingPattern = OneOf(llts.BindingPattern...)
	CaseClause = OneOf(llts.CaseClause...)
	ClassElement = OneOf(llts.ClassElement...)
	Decl = OneOf(llts.Decl...)
	Decorator = OneOf(llts.Decorator...)
	ElementPattern = OneOf(llts.ElementPattern...)
	ExportElement = OneOf(llts.ExportElement...)
	Expr = OneOf(llts.Expr...)
	IterationStmt = OneOf(llts.IterationStmt...)
	MethodDefinition = OneOf(llts.MethodDefinition...)
	Modifier = OneOf(llts.Modifier...)
	ModuleItem = OneOf(llts.ModuleItem...)
	NamedImport = OneOf(llts.NamedImport...)
	Parameter = OneOf(llts.Parameter...)
	PropertyDefinition = OneOf(llts.PropertyDefinition...)
	PropertyName = OneOf(llts.PropertyName...)
	PropertyPattern = OneOf(llts.PropertyPattern...)
	Stmt = OneOf(llts.Stmt...)
	StmtListItem = OneOf(llts.StmtListItem...)
	TsAmbientElement = OneOf(llts.TsAmbientElement...)
	TsType = OneOf(llts.TsType...)
	TypeMember = OneOf(llts.TypeMember...)
)

func OneOf(types ...llts.NodeType) Selector {
	if len(types) == 0 {
		return func(llts.NodeType) bool { return false }
	}
	const bits = 32
	max := 1
	for _, t := range types {
		if int(t) > max {
			max = int(t)
		}
	}
	size := (max + bits) / bits
	bitarr := make([]uint32, size)
	for _, t := range types {
		bitarr[uint(t)/bits] |= 1 << (uint(t) % bits)
	}
	return func(t llts.NodeType) bool {
		i := uint(t)/bits
		return int(i) < len(bitarr) && bitarr[i]&(1<<(uint(t)%bits)) != 0
	}
}
