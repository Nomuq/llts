// generated by Textmapper; DO NOT EDIT

package ast

import (
	"github.com/satishbabariya/llts"
	"github.com/satishbabariya/llts/selector"
)

// Interfaces.

type TsNode interface {
	TsNode() *Node
}

type Token struct {
	*Node
}

type NilNode struct {}

var nilInstance = &NilNode{}

// All types implement TsNode.
func (n Abstract) TsNode() *Node { return n.Node }
func (n AccessibilityModifier) TsNode() *Node { return n.Node }
func (n AdditiveExpr) TsNode() *Node { return n.Node }
func (n Arguments) TsNode() *Node { return n.Node }
func (n ArrayLiteral) TsNode() *Node { return n.Node }
func (n ArrayPattern) TsNode() *Node { return n.Node }
func (n ArrayType) TsNode() *Node { return n.Node }
func (n ArrowFunc) TsNode() *Node { return n.Node }
func (n AssertsType) TsNode() *Node { return n.Node }
func (n AssignmentExpr) TsNode() *Node { return n.Node }
func (n AssignmentOperator) TsNode() *Node { return n.Node }
func (n AsyncArrowFunc) TsNode() *Node { return n.Node }
func (n AsyncFunc) TsNode() *Node { return n.Node }
func (n AsyncFuncExpr) TsNode() *Node { return n.Node }
func (n AsyncMethod) TsNode() *Node { return n.Node }
func (n AwaitExpr) TsNode() *Node { return n.Node }
func (n BindingRestElement) TsNode() *Node { return n.Node }
func (n BitwiseAND) TsNode() *Node { return n.Node }
func (n BitwiseOR) TsNode() *Node { return n.Node }
func (n BitwiseXOR) TsNode() *Node { return n.Node }
func (n Block) TsNode() *Node { return n.Node }
func (n Body) TsNode() *Node { return n.Node }
func (n BreakStmt) TsNode() *Node { return n.Node }
func (n CallExpr) TsNode() *Node { return n.Node }
func (n CallSignature) TsNode() *Node { return n.Node }
func (n Case) TsNode() *Node { return n.Node }
func (n Catch) TsNode() *Node { return n.Node }
func (n Class) TsNode() *Node { return n.Node }
func (n ClassBody) TsNode() *Node { return n.Node }
func (n ClassExpr) TsNode() *Node { return n.Node }
func (n CoalesceExpr) TsNode() *Node { return n.Node }
func (n CommaExpr) TsNode() *Node { return n.Node }
func (n ComputedPropertyName) TsNode() *Node { return n.Node }
func (n ConciseBody) TsNode() *Node { return n.Node }
func (n ConditionalExpr) TsNode() *Node { return n.Node }
func (n ConstructSignature) TsNode() *Node { return n.Node }
func (n ConstructorType) TsNode() *Node { return n.Node }
func (n ContinueStmt) TsNode() *Node { return n.Node }
func (n DebuggerStmt) TsNode() *Node { return n.Node }
func (n Declare) TsNode() *Node { return n.Node }
func (n DecoratorCall) TsNode() *Node { return n.Node }
func (n DecoratorExpr) TsNode() *Node { return n.Node }
func (n Default) TsNode() *Node { return n.Node }
func (n DefaultParameter) TsNode() *Node { return n.Node }
func (n DoWhileStmt) TsNode() *Node { return n.Node }
func (n ElementBinding) TsNode() *Node { return n.Node }
func (n EmptyDecl) TsNode() *Node { return n.Node }
func (n EmptyStmt) TsNode() *Node { return n.Node }
func (n EqualityExpr) TsNode() *Node { return n.Node }
func (n ExponentiationExpr) TsNode() *Node { return n.Node }
func (n ExportClause) TsNode() *Node { return n.Node }
func (n ExportDecl) TsNode() *Node { return n.Node }
func (n ExportDefault) TsNode() *Node { return n.Node }
func (n ExportSpec) TsNode() *Node { return n.Node }
func (n ExprStmt) TsNode() *Node { return n.Node }
func (n Extends) TsNode() *Node { return n.Node }
func (n Finally) TsNode() *Node { return n.Node }
func (n ForBinding) TsNode() *Node { return n.Node }
func (n ForCondition) TsNode() *Node { return n.Node }
func (n ForFinalExpr) TsNode() *Node { return n.Node }
func (n ForInStmt) TsNode() *Node { return n.Node }
func (n ForInStmtWithVar) TsNode() *Node { return n.Node }
func (n ForOfStmt) TsNode() *Node { return n.Node }
func (n ForOfStmtWithVar) TsNode() *Node { return n.Node }
func (n ForStmt) TsNode() *Node { return n.Node }
func (n ForStmtWithVar) TsNode() *Node { return n.Node }
func (n Func) TsNode() *Node { return n.Node }
func (n FuncExpr) TsNode() *Node { return n.Node }
func (n FuncType) TsNode() *Node { return n.Node }
func (n Generator) TsNode() *Node { return n.Node }
func (n GeneratorExpr) TsNode() *Node { return n.Node }
func (n GeneratorMethod) TsNode() *Node { return n.Node }
func (n Getter) TsNode() *Node { return n.Node }
func (n IdentExpr) TsNode() *Node { return n.Node }
func (n IfStmt) TsNode() *Node { return n.Node }
func (n ImportDecl) TsNode() *Node { return n.Node }
func (n ImportSpec) TsNode() *Node { return n.Node }
func (n ImportType) TsNode() *Node { return n.Node }
func (n InExpr) TsNode() *Node { return n.Node }
func (n IndexAccess) TsNode() *Node { return n.Node }
func (n IndexSignature) TsNode() *Node { return n.Node }
func (n IndexedAccessType) TsNode() *Node { return n.Node }
func (n Initializer) TsNode() *Node { return n.Node }
func (n InstanceOfExpr) TsNode() *Node { return n.Node }
func (n IntersectionType) TsNode() *Node { return n.Node }
func (n KeyOfType) TsNode() *Node { return n.Node }
func (n LabelIdent) TsNode() *Node { return n.Node }
func (n LabelledStmt) TsNode() *Node { return n.Node }
func (n LetOrConst) TsNode() *Node { return n.Node }
func (n LexicalBinding) TsNode() *Node { return n.Node }
func (n LexicalDecl) TsNode() *Node { return n.Node }
func (n Literal) TsNode() *Node { return n.Node }
func (n LiteralPropertyName) TsNode() *Node { return n.Node }
func (n LiteralType) TsNode() *Node { return n.Node }
func (n LogicalAND) TsNode() *Node { return n.Node }
func (n LogicalOR) TsNode() *Node { return n.Node }
func (n MappedType) TsNode() *Node { return n.Node }
func (n MemberMethod) TsNode() *Node { return n.Node }
func (n MemberVar) TsNode() *Node { return n.Node }
func (n Method) TsNode() *Node { return n.Node }
func (n MethodSignature) TsNode() *Node { return n.Node }
func (n Module) TsNode() *Node { return n.Node }
func (n ModuleSpec) TsNode() *Node { return n.Node }
func (n MultiplicativeExpr) TsNode() *Node { return n.Node }
func (n NameIdent) TsNode() *Node { return n.Node }
func (n NameSpaceImport) TsNode() *Node { return n.Node }
func (n NamedImports) TsNode() *Node { return n.Node }
func (n NewExpr) TsNode() *Node { return n.Node }
func (n NewTarget) TsNode() *Node { return n.Node }
func (n NoElement) TsNode() *Node { return n.Node }
func (n NonNullableType) TsNode() *Node { return n.Node }
func (n NullableType) TsNode() *Node { return n.Node }
func (n ObjectLiteral) TsNode() *Node { return n.Node }
func (n ObjectMethod) TsNode() *Node { return n.Node }
func (n ObjectPattern) TsNode() *Node { return n.Node }
func (n ObjectType) TsNode() *Node { return n.Node }
func (n OptionalCallExpr) TsNode() *Node { return n.Node }
func (n OptionalIndexAccess) TsNode() *Node { return n.Node }
func (n OptionalPropertyAccess) TsNode() *Node { return n.Node }
func (n Parameters) TsNode() *Node { return n.Node }
func (n Parenthesized) TsNode() *Node { return n.Node }
func (n ParenthesizedType) TsNode() *Node { return n.Node }
func (n PostDec) TsNode() *Node { return n.Node }
func (n PostInc) TsNode() *Node { return n.Node }
func (n PreDec) TsNode() *Node { return n.Node }
func (n PreInc) TsNode() *Node { return n.Node }
func (n PredefinedType) TsNode() *Node { return n.Node }
func (n Property) TsNode() *Node { return n.Node }
func (n PropertyAccess) TsNode() *Node { return n.Node }
func (n PropertyBinding) TsNode() *Node { return n.Node }
func (n PropertySignature) TsNode() *Node { return n.Node }
func (n Readonly) TsNode() *Node { return n.Node }
func (n ReadonlyType) TsNode() *Node { return n.Node }
func (n ReferenceIdent) TsNode() *Node { return n.Node }
func (n RelationalExpr) TsNode() *Node { return n.Node }
func (n RestParameter) TsNode() *Node { return n.Node }
func (n RestType) TsNode() *Node { return n.Node }
func (n ReturnStmt) TsNode() *Node { return n.Node }
func (n Setter) TsNode() *Node { return n.Node }
func (n ShiftExpr) TsNode() *Node { return n.Node }
func (n ShorthandProperty) TsNode() *Node { return n.Node }
func (n SingleNameBinding) TsNode() *Node { return n.Node }
func (n SpreadElement) TsNode() *Node { return n.Node }
func (n SpreadProperty) TsNode() *Node { return n.Node }
func (n Static) TsNode() *Node { return n.Node }
func (n SuperExpr) TsNode() *Node { return n.Node }
func (n SwitchStmt) TsNode() *Node { return n.Node }
func (n SyntaxProblem) TsNode() *Node { return n.Node }
func (n This) TsNode() *Node { return n.Node }
func (n ThisType) TsNode() *Node { return n.Node }
func (n ThrowStmt) TsNode() *Node { return n.Node }
func (n TryStmt) TsNode() *Node { return n.Node }
func (n TsAmbientBinding) TsNode() *Node { return n.Node }
func (n TsAmbientClass) TsNode() *Node { return n.Node }
func (n TsAmbientEnum) TsNode() *Node { return n.Node }
func (n TsAmbientExportDecl) TsNode() *Node { return n.Node }
func (n TsAmbientFunc) TsNode() *Node { return n.Node }
func (n TsAmbientGlobal) TsNode() *Node { return n.Node }
func (n TsAmbientImportAlias) TsNode() *Node { return n.Node }
func (n TsAmbientInterface) TsNode() *Node { return n.Node }
func (n TsAmbientModule) TsNode() *Node { return n.Node }
func (n TsAmbientNamespace) TsNode() *Node { return n.Node }
func (n TsAmbientTypeAlias) TsNode() *Node { return n.Node }
func (n TsAmbientVar) TsNode() *Node { return n.Node }
func (n TsAsConstExpr) TsNode() *Node { return n.Node }
func (n TsAsExpr) TsNode() *Node { return n.Node }
func (n TsCastExpr) TsNode() *Node { return n.Node }
func (n TsConditional) TsNode() *Node { return n.Node }
func (n TsConst) TsNode() *Node { return n.Node }
func (n TsDynamicImport) TsNode() *Node { return n.Node }
func (n TsEnum) TsNode() *Node { return n.Node }
func (n TsEnumBody) TsNode() *Node { return n.Node }
func (n TsEnumMember) TsNode() *Node { return n.Node }
func (n TsExclToken) TsNode() *Node { return n.Node }
func (n TsExport) TsNode() *Node { return n.Node }
func (n TsExportAssignment) TsNode() *Node { return n.Node }
func (n TsImplementsClause) TsNode() *Node { return n.Node }
func (n TsImportAliasDecl) TsNode() *Node { return n.Node }
func (n TsImportRequireDecl) TsNode() *Node { return n.Node }
func (n TsIndexMemberDecl) TsNode() *Node { return n.Node }
func (n TsInterface) TsNode() *Node { return n.Node }
func (n TsInterfaceExtends) TsNode() *Node { return n.Node }
func (n TsNamespace) TsNode() *Node { return n.Node }
func (n TsNamespaceBody) TsNode() *Node { return n.Node }
func (n TsNamespaceExportDecl) TsNode() *Node { return n.Node }
func (n TsNonNull) TsNode() *Node { return n.Node }
func (n TsThisParameter) TsNode() *Node { return n.Node }
func (n TsTypeOnly) TsNode() *Node { return n.Node }
func (n TupleType) TsNode() *Node { return n.Node }
func (n TypeAliasDecl) TsNode() *Node { return n.Node }
func (n TypeAnnotation) TsNode() *Node { return n.Node }
func (n TypeArguments) TsNode() *Node { return n.Node }
func (n TypeConstraint) TsNode() *Node { return n.Node }
func (n TypeName) TsNode() *Node { return n.Node }
func (n TypeParameter) TsNode() *Node { return n.Node }
func (n TypeParameters) TsNode() *Node { return n.Node }
func (n TypePredicate) TsNode() *Node { return n.Node }
func (n TypeQuery) TsNode() *Node { return n.Node }
func (n TypeReference) TsNode() *Node { return n.Node }
func (n TypeVar) TsNode() *Node { return n.Node }
func (n UnaryExpr) TsNode() *Node { return n.Node }
func (n UnionType) TsNode() *Node { return n.Node }
func (n UniqueType) TsNode() *Node { return n.Node }
func (n Var) TsNode() *Node { return n.Node }
func (n VarDecl) TsNode() *Node { return n.Node }
func (n VarStmt) TsNode() *Node { return n.Node }
func (n WhileStmt) TsNode() *Node { return n.Node }
func (n WithStmt) TsNode() *Node { return n.Node }
func (n Yield) TsNode() *Node { return n.Node }
func (n Token) TsNode() *Node { return n.Node }
func (NilNode) TsNode() *Node { return nil }

type BindingPattern interface {
	TsNode
	bindingPatternNode()
}

// bindingPatternNode() ensures that only the following types can be
// assigned to BindingPattern.
//
func (ArrayPattern) bindingPatternNode() {}
func (ObjectPattern) bindingPatternNode() {}
func (NilNode) bindingPatternNode() {}

type CaseClause interface {
	TsNode
	caseClauseNode()
}

// caseClauseNode() ensures that only the following types can be
// assigned to CaseClause.
//
func (Case) caseClauseNode() {}
func (Default) caseClauseNode() {}
func (NilNode) caseClauseNode() {}

type ClassElement interface {
	TsNode
	classElementNode()
}

// classElementNode() ensures that only the following types can be
// assigned to ClassElement.
//
func (EmptyDecl) classElementNode() {}
func (MemberMethod) classElementNode() {}
func (MemberVar) classElementNode() {}
func (TsIndexMemberDecl) classElementNode() {}
func (NilNode) classElementNode() {}

type Decl interface {
	TsNode
	declNode()
}

// declNode() ensures that only the following types can be
// assigned to Decl.
//
func (AsyncFunc) declNode() {}
func (Class) declNode() {}
func (Func) declNode() {}
func (Generator) declNode() {}
func (LexicalDecl) declNode() {}
func (TsAmbientClass) declNode() {}
func (TsAmbientEnum) declNode() {}
func (TsAmbientExportDecl) declNode() {}
func (TsAmbientFunc) declNode() {}
func (TsAmbientGlobal) declNode() {}
func (TsAmbientImportAlias) declNode() {}
func (TsAmbientInterface) declNode() {}
func (TsAmbientModule) declNode() {}
func (TsAmbientNamespace) declNode() {}
func (TsAmbientTypeAlias) declNode() {}
func (TsAmbientVar) declNode() {}
func (TsEnum) declNode() {}
func (TsImportAliasDecl) declNode() {}
func (TsInterface) declNode() {}
func (TsNamespace) declNode() {}
func (TypeAliasDecl) declNode() {}
func (NilNode) declNode() {}

type Decorator interface {
	TsNode
	decoratorNode()
}

// decoratorNode() ensures that only the following types can be
// assigned to Decorator.
//
func (DecoratorCall) decoratorNode() {}
func (DecoratorExpr) decoratorNode() {}
func (NilNode) decoratorNode() {}

type ElementPattern interface {
	TsNode
	elementPatternNode()
}

// elementPatternNode() ensures that only the following types can be
// assigned to ElementPattern.
//
func (ElementBinding) elementPatternNode() {}
func (NoElement) elementPatternNode() {}
func (SingleNameBinding) elementPatternNode() {}
func (SyntaxProblem) elementPatternNode() {}
func (NilNode) elementPatternNode() {}

type ExportElement interface {
	TsNode
	exportElementNode()
}

// exportElementNode() ensures that only the following types can be
// assigned to ExportElement.
//
func (ExportSpec) exportElementNode() {}
func (SyntaxProblem) exportElementNode() {}
func (NilNode) exportElementNode() {}

type Expr interface {
	TsNode
	exprNode()
}

// exprNode() ensures that only the following types can be
// assigned to Expr.
//
func (AdditiveExpr) exprNode() {}
func (ArrayLiteral) exprNode() {}
func (ArrowFunc) exprNode() {}
func (AssignmentExpr) exprNode() {}
func (AsyncArrowFunc) exprNode() {}
func (AsyncFuncExpr) exprNode() {}
func (AwaitExpr) exprNode() {}
func (BitwiseAND) exprNode() {}
func (BitwiseOR) exprNode() {}
func (BitwiseXOR) exprNode() {}
func (CallExpr) exprNode() {}
func (ClassExpr) exprNode() {}
func (CoalesceExpr) exprNode() {}
func (CommaExpr) exprNode() {}
func (ConditionalExpr) exprNode() {}
func (EqualityExpr) exprNode() {}
func (ExponentiationExpr) exprNode() {}
func (FuncExpr) exprNode() {}
func (GeneratorExpr) exprNode() {}
func (IdentExpr) exprNode() {}
func (InExpr) exprNode() {}
func (IndexAccess) exprNode() {}
func (InstanceOfExpr) exprNode() {}
func (Literal) exprNode() {}
func (LogicalAND) exprNode() {}
func (LogicalOR) exprNode() {}
func (MultiplicativeExpr) exprNode() {}
func (NewExpr) exprNode() {}
func (NewTarget) exprNode() {}
func (NoElement) exprNode() {}
func (ObjectLiteral) exprNode() {}
func (OptionalCallExpr) exprNode() {}
func (OptionalIndexAccess) exprNode() {}
func (OptionalPropertyAccess) exprNode() {}
func (Parenthesized) exprNode() {}
func (PostDec) exprNode() {}
func (PostInc) exprNode() {}
func (PreDec) exprNode() {}
func (PreInc) exprNode() {}
func (PropertyAccess) exprNode() {}
func (RelationalExpr) exprNode() {}
func (ShiftExpr) exprNode() {}
func (SpreadElement) exprNode() {}
func (SuperExpr) exprNode() {}
func (This) exprNode() {}
func (TsAsConstExpr) exprNode() {}
func (TsAsExpr) exprNode() {}
func (TsCastExpr) exprNode() {}
func (TsDynamicImport) exprNode() {}
func (TsNonNull) exprNode() {}
func (UnaryExpr) exprNode() {}
func (Yield) exprNode() {}
func (NilNode) exprNode() {}

type IterationStmt interface {
	TsNode
	iterationStmtNode()
}

// iterationStmtNode() ensures that only the following types can be
// assigned to IterationStmt.
//
func (DoWhileStmt) iterationStmtNode() {}
func (ForInStmt) iterationStmtNode() {}
func (ForInStmtWithVar) iterationStmtNode() {}
func (ForOfStmt) iterationStmtNode() {}
func (ForOfStmtWithVar) iterationStmtNode() {}
func (ForStmt) iterationStmtNode() {}
func (ForStmtWithVar) iterationStmtNode() {}
func (WhileStmt) iterationStmtNode() {}
func (NilNode) iterationStmtNode() {}

type MethodDefinition interface {
	TsNode
	methodDefinitionNode()
}

// methodDefinitionNode() ensures that only the following types can be
// assigned to MethodDefinition.
//
func (AsyncMethod) methodDefinitionNode() {}
func (GeneratorMethod) methodDefinitionNode() {}
func (Getter) methodDefinitionNode() {}
func (Method) methodDefinitionNode() {}
func (Setter) methodDefinitionNode() {}
func (NilNode) methodDefinitionNode() {}

type Modifier interface {
	TsNode
	modifierNode()
}

// modifierNode() ensures that only the following types can be
// assigned to Modifier.
//
func (Abstract) modifierNode() {}
func (AccessibilityModifier) modifierNode() {}
func (Declare) modifierNode() {}
func (DecoratorCall) modifierNode() {}
func (DecoratorExpr) modifierNode() {}
func (Readonly) modifierNode() {}
func (Static) modifierNode() {}
func (NilNode) modifierNode() {}

type ModuleItem interface {
	TsNode
	moduleItemNode()
}

// moduleItemNode() ensures that only the following types can be
// assigned to ModuleItem.
//
func (AsyncFunc) moduleItemNode() {}
func (Block) moduleItemNode() {}
func (BreakStmt) moduleItemNode() {}
func (Class) moduleItemNode() {}
func (ContinueStmt) moduleItemNode() {}
func (DebuggerStmt) moduleItemNode() {}
func (DoWhileStmt) moduleItemNode() {}
func (EmptyStmt) moduleItemNode() {}
func (ExportDecl) moduleItemNode() {}
func (ExportDefault) moduleItemNode() {}
func (ExprStmt) moduleItemNode() {}
func (ForInStmt) moduleItemNode() {}
func (ForInStmtWithVar) moduleItemNode() {}
func (ForOfStmt) moduleItemNode() {}
func (ForOfStmtWithVar) moduleItemNode() {}
func (ForStmt) moduleItemNode() {}
func (ForStmtWithVar) moduleItemNode() {}
func (Func) moduleItemNode() {}
func (Generator) moduleItemNode() {}
func (IfStmt) moduleItemNode() {}
func (ImportDecl) moduleItemNode() {}
func (LabelledStmt) moduleItemNode() {}
func (LexicalDecl) moduleItemNode() {}
func (ReturnStmt) moduleItemNode() {}
func (SwitchStmt) moduleItemNode() {}
func (SyntaxProblem) moduleItemNode() {}
func (ThrowStmt) moduleItemNode() {}
func (TryStmt) moduleItemNode() {}
func (TsAmbientClass) moduleItemNode() {}
func (TsAmbientEnum) moduleItemNode() {}
func (TsAmbientExportDecl) moduleItemNode() {}
func (TsAmbientFunc) moduleItemNode() {}
func (TsAmbientGlobal) moduleItemNode() {}
func (TsAmbientImportAlias) moduleItemNode() {}
func (TsAmbientInterface) moduleItemNode() {}
func (TsAmbientModule) moduleItemNode() {}
func (TsAmbientNamespace) moduleItemNode() {}
func (TsAmbientTypeAlias) moduleItemNode() {}
func (TsAmbientVar) moduleItemNode() {}
func (TsEnum) moduleItemNode() {}
func (TsExportAssignment) moduleItemNode() {}
func (TsImportAliasDecl) moduleItemNode() {}
func (TsImportRequireDecl) moduleItemNode() {}
func (TsInterface) moduleItemNode() {}
func (TsNamespace) moduleItemNode() {}
func (TsNamespaceExportDecl) moduleItemNode() {}
func (TypeAliasDecl) moduleItemNode() {}
func (VarStmt) moduleItemNode() {}
func (WhileStmt) moduleItemNode() {}
func (WithStmt) moduleItemNode() {}
func (NilNode) moduleItemNode() {}

type NamedImport interface {
	TsNode
	namedImportNode()
}

// namedImportNode() ensures that only the following types can be
// assigned to NamedImport.
//
func (ImportSpec) namedImportNode() {}
func (SyntaxProblem) namedImportNode() {}
func (NilNode) namedImportNode() {}

type Parameter interface {
	TsNode
	parameterNode()
}

// parameterNode() ensures that only the following types can be
// assigned to Parameter.
//
func (DefaultParameter) parameterNode() {}
func (RestParameter) parameterNode() {}
func (SyntaxProblem) parameterNode() {}
func (TsThisParameter) parameterNode() {}
func (NilNode) parameterNode() {}

type PropertyDefinition interface {
	TsNode
	propertyDefinitionNode()
}

// propertyDefinitionNode() ensures that only the following types can be
// assigned to PropertyDefinition.
//
func (ObjectMethod) propertyDefinitionNode() {}
func (Property) propertyDefinitionNode() {}
func (ShorthandProperty) propertyDefinitionNode() {}
func (SpreadProperty) propertyDefinitionNode() {}
func (SyntaxProblem) propertyDefinitionNode() {}
func (NilNode) propertyDefinitionNode() {}

type PropertyName interface {
	TsNode
	propertyNameNode()
}

// propertyNameNode() ensures that only the following types can be
// assigned to PropertyName.
//
func (ComputedPropertyName) propertyNameNode() {}
func (LiteralPropertyName) propertyNameNode() {}
func (NilNode) propertyNameNode() {}

type PropertyPattern interface {
	TsNode
	propertyPatternNode()
}

// propertyPatternNode() ensures that only the following types can be
// assigned to PropertyPattern.
//
func (PropertyBinding) propertyPatternNode() {}
func (SingleNameBinding) propertyPatternNode() {}
func (SyntaxProblem) propertyPatternNode() {}
func (NilNode) propertyPatternNode() {}

type Stmt interface {
	TsNode
	stmtNode()
}

// stmtNode() ensures that only the following types can be
// assigned to Stmt.
//
func (Block) stmtNode() {}
func (BreakStmt) stmtNode() {}
func (ContinueStmt) stmtNode() {}
func (DebuggerStmt) stmtNode() {}
func (DoWhileStmt) stmtNode() {}
func (EmptyStmt) stmtNode() {}
func (ExprStmt) stmtNode() {}
func (ForInStmt) stmtNode() {}
func (ForInStmtWithVar) stmtNode() {}
func (ForOfStmt) stmtNode() {}
func (ForOfStmtWithVar) stmtNode() {}
func (ForStmt) stmtNode() {}
func (ForStmtWithVar) stmtNode() {}
func (IfStmt) stmtNode() {}
func (LabelledStmt) stmtNode() {}
func (ReturnStmt) stmtNode() {}
func (SwitchStmt) stmtNode() {}
func (ThrowStmt) stmtNode() {}
func (TryStmt) stmtNode() {}
func (VarStmt) stmtNode() {}
func (WhileStmt) stmtNode() {}
func (WithStmt) stmtNode() {}
func (NilNode) stmtNode() {}

type StmtListItem interface {
	TsNode
	stmtListItemNode()
}

// stmtListItemNode() ensures that only the following types can be
// assigned to StmtListItem.
//
func (AsyncFunc) stmtListItemNode() {}
func (Block) stmtListItemNode() {}
func (BreakStmt) stmtListItemNode() {}
func (Class) stmtListItemNode() {}
func (ContinueStmt) stmtListItemNode() {}
func (DebuggerStmt) stmtListItemNode() {}
func (DoWhileStmt) stmtListItemNode() {}
func (EmptyStmt) stmtListItemNode() {}
func (ExprStmt) stmtListItemNode() {}
func (ForInStmt) stmtListItemNode() {}
func (ForInStmtWithVar) stmtListItemNode() {}
func (ForOfStmt) stmtListItemNode() {}
func (ForOfStmtWithVar) stmtListItemNode() {}
func (ForStmt) stmtListItemNode() {}
func (ForStmtWithVar) stmtListItemNode() {}
func (Func) stmtListItemNode() {}
func (Generator) stmtListItemNode() {}
func (IfStmt) stmtListItemNode() {}
func (LabelledStmt) stmtListItemNode() {}
func (LexicalDecl) stmtListItemNode() {}
func (ReturnStmt) stmtListItemNode() {}
func (SwitchStmt) stmtListItemNode() {}
func (SyntaxProblem) stmtListItemNode() {}
func (ThrowStmt) stmtListItemNode() {}
func (TryStmt) stmtListItemNode() {}
func (TsAmbientClass) stmtListItemNode() {}
func (TsAmbientEnum) stmtListItemNode() {}
func (TsAmbientExportDecl) stmtListItemNode() {}
func (TsAmbientFunc) stmtListItemNode() {}
func (TsAmbientGlobal) stmtListItemNode() {}
func (TsAmbientImportAlias) stmtListItemNode() {}
func (TsAmbientInterface) stmtListItemNode() {}
func (TsAmbientModule) stmtListItemNode() {}
func (TsAmbientNamespace) stmtListItemNode() {}
func (TsAmbientTypeAlias) stmtListItemNode() {}
func (TsAmbientVar) stmtListItemNode() {}
func (TsEnum) stmtListItemNode() {}
func (TsImportAliasDecl) stmtListItemNode() {}
func (TsInterface) stmtListItemNode() {}
func (TsNamespace) stmtListItemNode() {}
func (TypeAliasDecl) stmtListItemNode() {}
func (VarStmt) stmtListItemNode() {}
func (WhileStmt) stmtListItemNode() {}
func (WithStmt) stmtListItemNode() {}
func (NilNode) stmtListItemNode() {}

type TsAmbientElement interface {
	TsNode
	tsAmbientElementNode()
}

// tsAmbientElementNode() ensures that only the following types can be
// assigned to TsAmbientElement.
//
func (TsAmbientClass) tsAmbientElementNode() {}
func (TsAmbientEnum) tsAmbientElementNode() {}
func (TsAmbientExportDecl) tsAmbientElementNode() {}
func (TsAmbientFunc) tsAmbientElementNode() {}
func (TsAmbientGlobal) tsAmbientElementNode() {}
func (TsAmbientImportAlias) tsAmbientElementNode() {}
func (TsAmbientInterface) tsAmbientElementNode() {}
func (TsAmbientModule) tsAmbientElementNode() {}
func (TsAmbientNamespace) tsAmbientElementNode() {}
func (TsAmbientTypeAlias) tsAmbientElementNode() {}
func (TsAmbientVar) tsAmbientElementNode() {}
func (NilNode) tsAmbientElementNode() {}

type TsType interface {
	TsNode
	tsTypeNode()
}

// tsTypeNode() ensures that only the following types can be
// assigned to TsType.
//
func (ArrayType) tsTypeNode() {}
func (AssertsType) tsTypeNode() {}
func (ConstructorType) tsTypeNode() {}
func (FuncType) tsTypeNode() {}
func (ImportType) tsTypeNode() {}
func (IndexedAccessType) tsTypeNode() {}
func (IntersectionType) tsTypeNode() {}
func (KeyOfType) tsTypeNode() {}
func (LiteralType) tsTypeNode() {}
func (MappedType) tsTypeNode() {}
func (NonNullableType) tsTypeNode() {}
func (NullableType) tsTypeNode() {}
func (ObjectType) tsTypeNode() {}
func (ParenthesizedType) tsTypeNode() {}
func (PredefinedType) tsTypeNode() {}
func (ReadonlyType) tsTypeNode() {}
func (RestType) tsTypeNode() {}
func (ThisType) tsTypeNode() {}
func (TsConditional) tsTypeNode() {}
func (TupleType) tsTypeNode() {}
func (TypePredicate) tsTypeNode() {}
func (TypeQuery) tsTypeNode() {}
func (TypeReference) tsTypeNode() {}
func (TypeVar) tsTypeNode() {}
func (UnionType) tsTypeNode() {}
func (UniqueType) tsTypeNode() {}
func (NilNode) tsTypeNode() {}

type TypeMember interface {
	TsNode
	typeMemberNode()
}

// typeMemberNode() ensures that only the following types can be
// assigned to TypeMember.
//
func (CallSignature) typeMemberNode() {}
func (ConstructSignature) typeMemberNode() {}
func (IndexSignature) typeMemberNode() {}
func (MethodSignature) typeMemberNode() {}
func (PropertySignature) typeMemberNode() {}
func (NilNode) typeMemberNode() {}

// Types.

type Abstract struct {
	*Node
}

type AccessibilityModifier struct {
	*Node
}

type AdditiveExpr struct {
	*Node
}

func (n AdditiveExpr) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n AdditiveExpr) Right() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type Arguments struct {
	*Node
}

func (n Arguments) TypeArguments() (TypeArguments, bool) {
	field := TypeArguments{n.Child(selector.TypeArguments)}
	return field, field.IsValid()}

func (n Arguments) List() []Expr {
	nodes := n.Children(selector.Expr)
	var ret = make([]Expr, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Expr))
	}
	return ret
}

type ArrayLiteral struct {
	*Node
}

func (n ArrayLiteral) List() []Expr {
	nodes := n.Children(selector.Expr)
	var ret = make([]Expr, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Expr))
	}
	return ret
}

type ArrayPattern struct {
	*Node
}

func (n ArrayPattern) List() []TsNode {
	nodes := n.Children(selector.OneOf(llts.AdditiveExpr, llts.ArrayLiteral, llts.ArrowFunc, llts.AssignmentExpr, llts.AsyncArrowFunc, llts.AsyncFuncExpr, llts.AwaitExpr, llts.BitwiseAND, llts.BitwiseOR, llts.BitwiseXOR, llts.CallExpr, llts.ClassExpr, llts.CoalesceExpr, llts.CommaExpr, llts.ConditionalExpr, llts.ElementBinding, llts.EqualityExpr, llts.ExponentiationExpr, llts.FuncExpr, llts.GeneratorExpr, llts.IdentExpr, llts.InExpr, llts.IndexAccess, llts.InstanceOfExpr, llts.Literal, llts.LogicalAND, llts.LogicalOR, llts.MultiplicativeExpr, llts.NewExpr, llts.NewTarget, llts.NoElement, llts.ObjectLiteral, llts.OptionalCallExpr, llts.OptionalIndexAccess, llts.OptionalPropertyAccess, llts.Parenthesized, llts.PostDec, llts.PostInc, llts.PreDec, llts.PreInc, llts.PropertyAccess, llts.RelationalExpr, llts.ShiftExpr, llts.SingleNameBinding, llts.SpreadElement, llts.SuperExpr, llts.SyntaxProblem, llts.This, llts.TsAsConstExpr, llts.TsAsExpr, llts.TsCastExpr, llts.TsDynamicImport, llts.TsNonNull, llts.UnaryExpr, llts.Yield))
	var ret = make([]TsNode, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(TsNode))
	}
	return ret
}

func (n ArrayPattern) BindingRestElement() (BindingRestElement, bool) {
	field := BindingRestElement{n.Child(selector.BindingRestElement)}
	return field, field.IsValid()}

type ArrayType struct {
	*Node
}

func (n ArrayType) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

type ArrowFunc struct {
	*Node
}

func (n ArrowFunc) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

func (n ArrowFunc) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n ArrowFunc) Parameters() (Parameters, bool) {
	field := Parameters{n.Child(selector.Parameters)}
	return field, field.IsValid()}

func (n ArrowFunc) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n ArrowFunc) Body() (Body, bool) {
	field := Body{n.Child(selector.Body)}
	return field, field.IsValid()}

func (n ArrowFunc) ConciseBody() (ConciseBody, bool) {
	field := ConciseBody{n.Child(selector.ConciseBody)}
	return field, field.IsValid()}

type AssertsType struct {
	*Node
}

func (n AssertsType) ReferenceIdent() (ReferenceIdent, bool) {
	field := ReferenceIdent{n.Child(selector.ReferenceIdent)}
	return field, field.IsValid()}

func (n AssertsType) This() (This, bool) {
	field := This{n.Child(selector.This)}
	return field, field.IsValid()}

func (n AssertsType) TsType() (TsType, bool) {
	field := ToTsNode(n.Child(selector.TsType)).(TsType)
	return field, field.TsNode() != nil}

type AssignmentExpr struct {
	*Node
}

func (n AssignmentExpr) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n AssignmentExpr) AssignmentOperator() (AssignmentOperator, bool) {
	field := AssignmentOperator{n.Child(selector.AssignmentOperator)}
	return field, field.IsValid()}

func (n AssignmentExpr) Right() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type AssignmentOperator struct {
	*Node
}

type AsyncArrowFunc struct {
	*Node
}

func (n AsyncArrowFunc) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

func (n AsyncArrowFunc) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n AsyncArrowFunc) Parameters() (Parameters, bool) {
	field := Parameters{n.Child(selector.Parameters)}
	return field, field.IsValid()}

func (n AsyncArrowFunc) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n AsyncArrowFunc) Body() (Body, bool) {
	field := Body{n.Child(selector.Body)}
	return field, field.IsValid()}

func (n AsyncArrowFunc) ConciseBody() (ConciseBody, bool) {
	field := ConciseBody{n.Child(selector.ConciseBody)}
	return field, field.IsValid()}

type AsyncFunc struct {
	*Node
}

func (n AsyncFunc) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

func (n AsyncFunc) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n AsyncFunc) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n AsyncFunc) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n AsyncFunc) Body() Body {
	return Body{n.Child(selector.Body)}
}

type AsyncFuncExpr struct {
	*Node
}

func (n AsyncFuncExpr) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

func (n AsyncFuncExpr) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n AsyncFuncExpr) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n AsyncFuncExpr) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n AsyncFuncExpr) Body() Body {
	return Body{n.Child(selector.Body)}
}

type AsyncMethod struct {
	*Node
}

func (n AsyncMethod) PropertyName() PropertyName {
	return ToTsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n AsyncMethod) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n AsyncMethod) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n AsyncMethod) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n AsyncMethod) Body() Body {
	return Body{n.Child(selector.Body)}
}

type AwaitExpr struct {
	*Node
}

func (n AwaitExpr) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type BindingRestElement struct {
	*Node
}

func (n BindingRestElement) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

type BitwiseAND struct {
	*Node
}

func (n BitwiseAND) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n BitwiseAND) Right() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type BitwiseOR struct {
	*Node
}

func (n BitwiseOR) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n BitwiseOR) Right() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type BitwiseXOR struct {
	*Node
}

func (n BitwiseXOR) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n BitwiseXOR) Right() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type Block struct {
	*Node
}

func (n Block) CaseClause() []CaseClause {
	nodes := n.Children(selector.CaseClause)
	var ret = make([]CaseClause, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(CaseClause))
	}
	return ret
}

func (n Block) StmtListItem() []StmtListItem {
	nodes := n.Children(selector.StmtListItem)
	var ret = make([]StmtListItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(StmtListItem))
	}
	return ret
}

type Body struct {
	*Node
}

func (n Body) StmtListItem() []StmtListItem {
	nodes := n.Children(selector.StmtListItem)
	var ret = make([]StmtListItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(StmtListItem))
	}
	return ret
}

type BreakStmt struct {
	*Node
}

func (n BreakStmt) LabelIdent() (LabelIdent, bool) {
	field := LabelIdent{n.Child(selector.LabelIdent)}
	return field, field.IsValid()}

type CallExpr struct {
	*Node
}

func (n CallExpr) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n CallExpr) Arguments() Arguments {
	return Arguments{n.Child(selector.Arguments)}
}

type CallSignature struct {
	*Node
}

func (n CallSignature) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n CallSignature) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n CallSignature) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

type Case struct {
	*Node
}

func (n Case) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n Case) StmtListItem() []StmtListItem {
	nodes := n.Children(selector.StmtListItem)
	var ret = make([]StmtListItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(StmtListItem))
	}
	return ret
}

type Catch struct {
	*Node
}

func (n Catch) BindingPattern() (BindingPattern, bool) {
	field := ToTsNode(n.Child(selector.BindingPattern)).(BindingPattern)
	return field, field.TsNode() != nil}

func (n Catch) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

func (n Catch) Block() Block {
	return Block{n.Child(selector.Block)}
}

type Class struct {
	*Node
}

func (n Class) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Modifier))
	}
	return ret
}

func (n Class) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

func (n Class) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n Class) Extends() (Extends, bool) {
	field := Extends{n.Child(selector.Extends)}
	return field, field.IsValid()}

func (n Class) TsImplementsClause() (TsImplementsClause, bool) {
	field := TsImplementsClause{n.Child(selector.TsImplementsClause)}
	return field, field.IsValid()}

func (n Class) ClassBody() ClassBody {
	return ClassBody{n.Child(selector.ClassBody)}
}

type ClassBody struct {
	*Node
}

func (n ClassBody) ClassElement() []ClassElement {
	nodes := n.Children(selector.ClassElement)
	var ret = make([]ClassElement, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(ClassElement))
	}
	return ret
}

type ClassExpr struct {
	*Node
}

func (n ClassExpr) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Modifier))
	}
	return ret
}

func (n ClassExpr) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

func (n ClassExpr) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n ClassExpr) Extends() (Extends, bool) {
	field := Extends{n.Child(selector.Extends)}
	return field, field.IsValid()}

func (n ClassExpr) TsImplementsClause() (TsImplementsClause, bool) {
	field := TsImplementsClause{n.Child(selector.TsImplementsClause)}
	return field, field.IsValid()}

func (n ClassExpr) ClassBody() ClassBody {
	return ClassBody{n.Child(selector.ClassBody)}
}

type CoalesceExpr struct {
	*Node
}

func (n CoalesceExpr) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n CoalesceExpr) Right() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type CommaExpr struct {
	*Node
}

func (n CommaExpr) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n CommaExpr) Right() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type ComputedPropertyName struct {
	*Node
}

func (n ComputedPropertyName) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type ConciseBody struct {
	*Node
}

func (n ConciseBody) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type ConditionalExpr struct {
	*Node
}

func (n ConditionalExpr) Cond() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n ConditionalExpr) Then() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

func (n ConditionalExpr) Else() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr).Next(selector.Expr)).(Expr)
}

type ConstructSignature struct {
	*Node
}

func (n ConstructSignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Modifier))
	}
	return ret
}

func (n ConstructSignature) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n ConstructSignature) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n ConstructSignature) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

type ConstructorType struct {
	*Node
}

func (n ConstructorType) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n ConstructorType) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n ConstructorType) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

type ContinueStmt struct {
	*Node
}

func (n ContinueStmt) LabelIdent() (LabelIdent, bool) {
	field := LabelIdent{n.Child(selector.LabelIdent)}
	return field, field.IsValid()}

type DebuggerStmt struct {
	*Node
}

type Declare struct {
	*Node
}

type DecoratorCall struct {
	*Node
}

func (n DecoratorCall) ReferenceIdent() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

func (n DecoratorCall) Arguments() Arguments {
	return Arguments{n.Child(selector.Arguments)}
}

type DecoratorExpr struct {
	*Node
}

func (n DecoratorExpr) ReferenceIdent() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

type Default struct {
	*Node
}

func (n Default) StmtListItem() []StmtListItem {
	nodes := n.Children(selector.StmtListItem)
	var ret = make([]StmtListItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(StmtListItem))
	}
	return ret
}

type DefaultParameter struct {
	*Node
}

func (n DefaultParameter) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Modifier))
	}
	return ret
}

func (n DefaultParameter) BindingPattern() (BindingPattern, bool) {
	field := ToTsNode(n.Child(selector.BindingPattern)).(BindingPattern)
	return field, field.TsNode() != nil}

func (n DefaultParameter) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

func (n DefaultParameter) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n DefaultParameter) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()}

type DoWhileStmt struct {
	*Node
}

func (n DoWhileStmt) Stmt() Stmt {
	return ToTsNode(n.Child(selector.Stmt)).(Stmt)
}

func (n DoWhileStmt) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type ElementBinding struct {
	*Node
}

func (n ElementBinding) BindingPattern() BindingPattern {
	return ToTsNode(n.Child(selector.BindingPattern)).(BindingPattern)
}

func (n ElementBinding) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()}

type EmptyDecl struct {
	*Node
}

type EmptyStmt struct {
	*Node
}

type EqualityExpr struct {
	*Node
}

func (n EqualityExpr) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n EqualityExpr) Right() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type ExponentiationExpr struct {
	*Node
}

func (n ExponentiationExpr) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n ExponentiationExpr) Right() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type ExportClause struct {
	*Node
}

func (n ExportClause) ExportElement() []ExportElement {
	nodes := n.Children(selector.ExportElement)
	var ret = make([]ExportElement, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(ExportElement))
	}
	return ret
}

type ExportDecl struct {
	*Node
}

func (n ExportDecl) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Modifier))
	}
	return ret
}

func (n ExportDecl) TsTypeOnly() (TsTypeOnly, bool) {
	field := TsTypeOnly{n.Child(selector.TsTypeOnly)}
	return field, field.IsValid()}

func (n ExportDecl) VarStmt() (VarStmt, bool) {
	field := VarStmt{n.Child(selector.VarStmt)}
	return field, field.IsValid()}

func (n ExportDecl) Decl() (Decl, bool) {
	field := ToTsNode(n.Child(selector.Decl)).(Decl)
	return field, field.TsNode() != nil}

func (n ExportDecl) ExportClause() (ExportClause, bool) {
	field := ExportClause{n.Child(selector.ExportClause)}
	return field, field.IsValid()}

func (n ExportDecl) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

func (n ExportDecl) ModuleSpec() (ModuleSpec, bool) {
	field := ModuleSpec{n.Child(selector.ModuleSpec)}
	return field, field.IsValid()}

type ExportDefault struct {
	*Node
}

func (n ExportDefault) Expr() (Expr, bool) {
	field := ToTsNode(n.Child(selector.Expr)).(Expr)
	return field, field.TsNode() != nil}

func (n ExportDefault) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Modifier))
	}
	return ret
}

func (n ExportDefault) Decl() (Decl, bool) {
	field := ToTsNode(n.Child(selector.Decl)).(Decl)
	return field, field.TsNode() != nil}

type ExportSpec struct {
	*Node
}

func (n ExportSpec) ReferenceIdent() ReferenceIdent {
	return ReferenceIdent{n.Child(selector.ReferenceIdent)}
}

func (n ExportSpec) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

type ExprStmt struct {
	*Node
}

func (n ExprStmt) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type Extends struct {
	*Node
}

func (n Extends) Expr() (Expr, bool) {
	field := ToTsNode(n.Child(selector.Expr)).(Expr)
	return field, field.TsNode() != nil}

func (n Extends) TypeReference() (TypeReference, bool) {
	field := TypeReference{n.Child(selector.TypeReference)}
	return field, field.IsValid()}

type Finally struct {
	*Node
}

func (n Finally) Block() Block {
	return Block{n.Child(selector.Block)}
}

type ForBinding struct {
	*Node
}

func (n ForBinding) BindingPattern() (BindingPattern, bool) {
	field := ToTsNode(n.Child(selector.BindingPattern)).(BindingPattern)
	return field, field.TsNode() != nil}

func (n ForBinding) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

type ForCondition struct {
	*Node
}

func (n ForCondition) Expr() (Expr, bool) {
	field := ToTsNode(n.Child(selector.Expr)).(Expr)
	return field, field.TsNode() != nil}

type ForFinalExpr struct {
	*Node
}

func (n ForFinalExpr) Expr() (Expr, bool) {
	field := ToTsNode(n.Child(selector.Expr)).(Expr)
	return field, field.TsNode() != nil}

type ForInStmt struct {
	*Node
}

func (n ForInStmt) Var() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n ForInStmt) Object() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

func (n ForInStmt) Stmt() Stmt {
	return ToTsNode(n.Child(selector.Stmt)).(Stmt)
}

type ForInStmtWithVar struct {
	*Node
}

func (n ForInStmtWithVar) LetOrConst() (LetOrConst, bool) {
	field := LetOrConst{n.Child(selector.LetOrConst)}
	return field, field.IsValid()}

func (n ForInStmtWithVar) Var() (Var, bool) {
	field := Var{n.Child(selector.Var)}
	return field, field.IsValid()}

func (n ForInStmtWithVar) ForBinding() ForBinding {
	return ForBinding{n.Child(selector.ForBinding)}
}

func (n ForInStmtWithVar) Object() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n ForInStmtWithVar) Stmt() Stmt {
	return ToTsNode(n.Child(selector.Stmt)).(Stmt)
}

type ForOfStmt struct {
	*Node
}

func (n ForOfStmt) Var() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n ForOfStmt) Iterable() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

func (n ForOfStmt) Stmt() Stmt {
	return ToTsNode(n.Child(selector.Stmt)).(Stmt)
}

type ForOfStmtWithVar struct {
	*Node
}

func (n ForOfStmtWithVar) LetOrConst() (LetOrConst, bool) {
	field := LetOrConst{n.Child(selector.LetOrConst)}
	return field, field.IsValid()}

func (n ForOfStmtWithVar) Var() (Var, bool) {
	field := Var{n.Child(selector.Var)}
	return field, field.IsValid()}

func (n ForOfStmtWithVar) ForBinding() ForBinding {
	return ForBinding{n.Child(selector.ForBinding)}
}

func (n ForOfStmtWithVar) Iterable() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n ForOfStmtWithVar) Stmt() Stmt {
	return ToTsNode(n.Child(selector.Stmt)).(Stmt)
}

type ForStmt struct {
	*Node
}

func (n ForStmt) Var() (Expr, bool) {
	field := ToTsNode(n.Child(selector.Expr)).(Expr)
	return field, field.TsNode() != nil}

func (n ForStmt) ForCondition() ForCondition {
	return ForCondition{n.Child(selector.ForCondition)}
}

func (n ForStmt) ForFinalExpr() ForFinalExpr {
	return ForFinalExpr{n.Child(selector.ForFinalExpr)}
}

func (n ForStmt) Stmt() Stmt {
	return ToTsNode(n.Child(selector.Stmt)).(Stmt)
}

type ForStmtWithVar struct {
	*Node
}

func (n ForStmtWithVar) LetOrConst() (LetOrConst, bool) {
	field := LetOrConst{n.Child(selector.LetOrConst)}
	return field, field.IsValid()}

func (n ForStmtWithVar) Var() (Var, bool) {
	field := Var{n.Child(selector.Var)}
	return field, field.IsValid()}

func (n ForStmtWithVar) LexicalBinding() []LexicalBinding {
	nodes := n.Children(selector.LexicalBinding)
	var ret = make([]LexicalBinding, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, LexicalBinding{node})
	}
	return ret
}

func (n ForStmtWithVar) VarDecl() []VarDecl {
	nodes := n.Children(selector.VarDecl)
	var ret = make([]VarDecl, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, VarDecl{node})
	}
	return ret
}

func (n ForStmtWithVar) ForCondition() ForCondition {
	return ForCondition{n.Child(selector.ForCondition)}
}

func (n ForStmtWithVar) ForFinalExpr() ForFinalExpr {
	return ForFinalExpr{n.Child(selector.ForFinalExpr)}
}

func (n ForStmtWithVar) Stmt() Stmt {
	return ToTsNode(n.Child(selector.Stmt)).(Stmt)
}

type Func struct {
	*Node
}

func (n Func) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

func (n Func) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n Func) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n Func) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n Func) Body() Body {
	return Body{n.Child(selector.Body)}
}

type FuncExpr struct {
	*Node
}

func (n FuncExpr) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

func (n FuncExpr) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n FuncExpr) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n FuncExpr) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n FuncExpr) Body() Body {
	return Body{n.Child(selector.Body)}
}

type FuncType struct {
	*Node
}

func (n FuncType) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n FuncType) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n FuncType) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

type Generator struct {
	*Node
}

func (n Generator) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

func (n Generator) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n Generator) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n Generator) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n Generator) Body() Body {
	return Body{n.Child(selector.Body)}
}

type GeneratorExpr struct {
	*Node
}

func (n GeneratorExpr) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

func (n GeneratorExpr) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n GeneratorExpr) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n GeneratorExpr) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n GeneratorExpr) Body() Body {
	return Body{n.Child(selector.Body)}
}

type GeneratorMethod struct {
	*Node
}

func (n GeneratorMethod) PropertyName() PropertyName {
	return ToTsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n GeneratorMethod) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n GeneratorMethod) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n GeneratorMethod) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n GeneratorMethod) Body() Body {
	return Body{n.Child(selector.Body)}
}

type Getter struct {
	*Node
}

func (n Getter) PropertyName() PropertyName {
	return ToTsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Getter) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n Getter) Body() Body {
	return Body{n.Child(selector.Body)}
}

type IdentExpr struct {
	*Node
}

func (n IdentExpr) ReferenceIdent() ReferenceIdent {
	return ReferenceIdent{n.Child(selector.ReferenceIdent)}
}

type IfStmt struct {
	*Node
}

func (n IfStmt) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n IfStmt) Then() Stmt {
	return ToTsNode(n.Child(selector.Stmt)).(Stmt)
}

func (n IfStmt) Else() (Stmt, bool) {
	field := ToTsNode(n.Child(selector.Stmt).Next(selector.Stmt)).(Stmt)
	return field, field.TsNode() != nil}

type ImportDecl struct {
	*Node
}

func (n ImportDecl) TsTypeOnly() (TsTypeOnly, bool) {
	field := TsTypeOnly{n.Child(selector.TsTypeOnly)}
	return field, field.IsValid()}

func (n ImportDecl) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

func (n ImportDecl) NameSpaceImport() (NameSpaceImport, bool) {
	field := NameSpaceImport{n.Child(selector.NameSpaceImport)}
	return field, field.IsValid()}

func (n ImportDecl) NamedImports() (NamedImports, bool) {
	field := NamedImports{n.Child(selector.NamedImports)}
	return field, field.IsValid()}

func (n ImportDecl) ModuleSpec() ModuleSpec {
	return ModuleSpec{n.Child(selector.ModuleSpec)}
}

type ImportSpec struct {
	*Node
}

func (n ImportSpec) ReferenceIdent() (ReferenceIdent, bool) {
	field := ReferenceIdent{n.Child(selector.ReferenceIdent)}
	return field, field.IsValid()}

func (n ImportSpec) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

type ImportType struct {
	*Node
}

func (n ImportType) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

func (n ImportType) ReferenceIdent() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

func (n ImportType) TypeArguments() (TypeArguments, bool) {
	field := TypeArguments{n.Child(selector.TypeArguments)}
	return field, field.IsValid()}

type InExpr struct {
	*Node
}

func (n InExpr) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n InExpr) Right() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type IndexAccess struct {
	*Node
}

func (n IndexAccess) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n IndexAccess) Index() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type IndexSignature struct {
	*Node
}

func (n IndexSignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Modifier))
	}
	return ret
}

func (n IndexSignature) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n IndexSignature) PredefinedType() PredefinedType {
	return PredefinedType{n.Child(selector.PredefinedType)}
}

func (n IndexSignature) TypeAnnotation() TypeAnnotation {
	return TypeAnnotation{n.Child(selector.TypeAnnotation)}
}

type IndexedAccessType struct {
	*Node
}

func (n IndexedAccessType) Left() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

func (n IndexedAccessType) Index() TsType {
	return ToTsNode(n.Child(selector.TsType).Next(selector.TsType)).(TsType)
}

type Initializer struct {
	*Node
}

func (n Initializer) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type InstanceOfExpr struct {
	*Node
}

func (n InstanceOfExpr) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n InstanceOfExpr) Right() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type IntersectionType struct {
	*Node
}

func (n IntersectionType) Inner() []TsType {
	nodes := n.Children(selector.TsType)
	var ret = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(TsType))
	}
	return ret
}

type KeyOfType struct {
	*Node
}

func (n KeyOfType) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

type LabelIdent struct {
	*Node
}

type LabelledStmt struct {
	*Node
}

func (n LabelledStmt) LabelIdent() LabelIdent {
	return LabelIdent{n.Child(selector.LabelIdent)}
}

func (n LabelledStmt) Func() (Func, bool) {
	field := Func{n.Child(selector.Func)}
	return field, field.IsValid()}

func (n LabelledStmt) Stmt() (Stmt, bool) {
	field := ToTsNode(n.Child(selector.Stmt)).(Stmt)
	return field, field.TsNode() != nil}

type LetOrConst struct {
	*Node
}

type LexicalBinding struct {
	*Node
}

func (n LexicalBinding) BindingPattern() (BindingPattern, bool) {
	field := ToTsNode(n.Child(selector.BindingPattern)).(BindingPattern)
	return field, field.TsNode() != nil}

func (n LexicalBinding) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

func (n LexicalBinding) TsExclToken() (TsExclToken, bool) {
	field := TsExclToken{n.Child(selector.TsExclToken)}
	return field, field.IsValid()}

func (n LexicalBinding) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n LexicalBinding) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()}

type LexicalDecl struct {
	*Node
}

func (n LexicalDecl) LetOrConst() LetOrConst {
	return LetOrConst{n.Child(selector.LetOrConst)}
}

func (n LexicalDecl) LexicalBinding() []LexicalBinding {
	nodes := n.Children(selector.LexicalBinding)
	var ret = make([]LexicalBinding, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, LexicalBinding{node})
	}
	return ret
}

type Literal struct {
	*Node
}

type LiteralPropertyName struct {
	*Node
}

func (n LiteralPropertyName) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

type LiteralType struct {
	*Node
}

type LogicalAND struct {
	*Node
}

func (n LogicalAND) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n LogicalAND) Right() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type LogicalOR struct {
	*Node
}

func (n LogicalOR) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n LogicalOR) Right() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type MappedType struct {
	*Node
}

func (n MappedType) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n MappedType) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

func (n MappedType) TypeAnnotation() TypeAnnotation {
	return TypeAnnotation{n.Child(selector.TypeAnnotation)}
}

type MemberMethod struct {
	*Node
}

func (n MemberMethod) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Modifier))
	}
	return ret
}

func (n MemberMethod) MethodDefinition() MethodDefinition {
	return ToTsNode(n.Child(selector.MethodDefinition)).(MethodDefinition)
}

type MemberVar struct {
	*Node
}

func (n MemberVar) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Modifier))
	}
	return ret
}

func (n MemberVar) PropertyName() PropertyName {
	return ToTsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n MemberVar) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n MemberVar) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()}

type Method struct {
	*Node
}

func (n Method) PropertyName() PropertyName {
	return ToTsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Method) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n Method) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n Method) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n Method) Body() Body {
	return Body{n.Child(selector.Body)}
}

type MethodSignature struct {
	*Node
}

func (n MethodSignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Modifier))
	}
	return ret
}

func (n MethodSignature) PropertyName() PropertyName {
	return ToTsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n MethodSignature) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n MethodSignature) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n MethodSignature) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

type Module struct {
	*Node
}

func (n Module) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var ret = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(ModuleItem))
	}
	return ret
}

type ModuleSpec struct {
	*Node
}

type MultiplicativeExpr struct {
	*Node
}

func (n MultiplicativeExpr) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n MultiplicativeExpr) Right() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type NameIdent struct {
	*Node
}

type NameSpaceImport struct {
	*Node
}

func (n NameSpaceImport) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

type NamedImports struct {
	*Node
}

func (n NamedImports) NamedImport() []NamedImport {
	nodes := n.Children(selector.NamedImport)
	var ret = make([]NamedImport, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(NamedImport))
	}
	return ret
}

type NewExpr struct {
	*Node
}

func (n NewExpr) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n NewExpr) Arguments() (Arguments, bool) {
	field := Arguments{n.Child(selector.Arguments)}
	return field, field.IsValid()}

type NewTarget struct {
	*Node
}

type NoElement struct {
	*Node
}

type NonNullableType struct {
	*Node
}

func (n NonNullableType) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

type NullableType struct {
	*Node
}

func (n NullableType) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

type ObjectLiteral struct {
	*Node
}

func (n ObjectLiteral) PropertyDefinition() []PropertyDefinition {
	nodes := n.Children(selector.PropertyDefinition)
	var ret = make([]PropertyDefinition, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(PropertyDefinition))
	}
	return ret
}

type ObjectMethod struct {
	*Node
}

func (n ObjectMethod) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Modifier))
	}
	return ret
}

func (n ObjectMethod) MethodDefinition() MethodDefinition {
	return ToTsNode(n.Child(selector.MethodDefinition)).(MethodDefinition)
}

type ObjectPattern struct {
	*Node
}

func (n ObjectPattern) PropertyPattern() []PropertyPattern {
	nodes := n.Children(selector.PropertyPattern)
	var ret = make([]PropertyPattern, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(PropertyPattern))
	}
	return ret
}

func (n ObjectPattern) BindingRestElement() (BindingRestElement, bool) {
	field := BindingRestElement{n.Child(selector.BindingRestElement)}
	return field, field.IsValid()}

type ObjectType struct {
	*Node
}

func (n ObjectType) TypeMember() []TypeMember {
	nodes := n.Children(selector.TypeMember)
	var ret = make([]TypeMember, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(TypeMember))
	}
	return ret
}

type OptionalCallExpr struct {
	*Node
}

func (n OptionalCallExpr) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n OptionalCallExpr) Arguments() Arguments {
	return Arguments{n.Child(selector.Arguments)}
}

type OptionalIndexAccess struct {
	*Node
}

func (n OptionalIndexAccess) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n OptionalIndexAccess) Index() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type OptionalPropertyAccess struct {
	*Node
}

func (n OptionalPropertyAccess) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n OptionalPropertyAccess) Selector() ReferenceIdent {
	return ReferenceIdent{n.Child(selector.ReferenceIdent)}
}

type Parameters struct {
	*Node
}

func (n Parameters) Parameter() []Parameter {
	nodes := n.Children(selector.Parameter)
	var ret = make([]Parameter, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Parameter))
	}
	return ret
}

type Parenthesized struct {
	*Node
}

func (n Parenthesized) Expr() (Expr, bool) {
	field := ToTsNode(n.Child(selector.Expr)).(Expr)
	return field, field.TsNode() != nil}

func (n Parenthesized) SyntaxProblem() (SyntaxProblem, bool) {
	field := SyntaxProblem{n.Child(selector.SyntaxProblem)}
	return field, field.IsValid()}

type ParenthesizedType struct {
	*Node
}

func (n ParenthesizedType) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

type PostDec struct {
	*Node
}

func (n PostDec) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type PostInc struct {
	*Node
}

func (n PostInc) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type PreDec struct {
	*Node
}

func (n PreDec) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type PreInc struct {
	*Node
}

func (n PreInc) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type PredefinedType struct {
	*Node
}

type Property struct {
	*Node
}

func (n Property) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Modifier))
	}
	return ret
}

func (n Property) PropertyName() PropertyName {
	return ToTsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Property) Value() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type PropertyAccess struct {
	*Node
}

func (n PropertyAccess) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n PropertyAccess) Selector() ReferenceIdent {
	return ReferenceIdent{n.Child(selector.ReferenceIdent)}
}

type PropertyBinding struct {
	*Node
}

func (n PropertyBinding) PropertyName() PropertyName {
	return ToTsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n PropertyBinding) ElementPattern() ElementPattern {
	return ToTsNode(n.Child(selector.ElementPattern)).(ElementPattern)
}

type PropertySignature struct {
	*Node
}

func (n PropertySignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Modifier))
	}
	return ret
}

func (n PropertySignature) PropertyName() PropertyName {
	return ToTsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n PropertySignature) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

type Readonly struct {
	*Node
}

type ReadonlyType struct {
	*Node
}

func (n ReadonlyType) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

type ReferenceIdent struct {
	*Node
}

type RelationalExpr struct {
	*Node
}

func (n RelationalExpr) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n RelationalExpr) Right() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type RestParameter struct {
	*Node
}

func (n RestParameter) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n RestParameter) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

type RestType struct {
	*Node
}

func (n RestType) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

type ReturnStmt struct {
	*Node
}

func (n ReturnStmt) Expr() (Expr, bool) {
	field := ToTsNode(n.Child(selector.Expr)).(Expr)
	return field, field.TsNode() != nil}

type Setter struct {
	*Node
}

func (n Setter) PropertyName() PropertyName {
	return ToTsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Setter) Parameter() Parameter {
	return ToTsNode(n.Child(selector.Parameter)).(Parameter)
}

func (n Setter) Body() Body {
	return Body{n.Child(selector.Body)}
}

type ShiftExpr struct {
	*Node
}

func (n ShiftExpr) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n ShiftExpr) Right() Expr {
	return ToTsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type ShorthandProperty struct {
	*Node
}

func (n ShorthandProperty) ReferenceIdent() ReferenceIdent {
	return ReferenceIdent{n.Child(selector.ReferenceIdent)}
}

type SingleNameBinding struct {
	*Node
}

func (n SingleNameBinding) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n SingleNameBinding) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()}

type SpreadElement struct {
	*Node
}

func (n SpreadElement) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type SpreadProperty struct {
	*Node
}

func (n SpreadProperty) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type Static struct {
	*Node
}

type SuperExpr struct {
	*Node
}

type SwitchStmt struct {
	*Node
}

func (n SwitchStmt) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n SwitchStmt) Block() Block {
	return Block{n.Child(selector.Block)}
}

type SyntaxProblem struct {
	*Node
}

func (n SyntaxProblem) ReferenceIdent() (ReferenceIdent, bool) {
	field := ReferenceIdent{n.Child(selector.ReferenceIdent)}
	return field, field.IsValid()}

func (n SyntaxProblem) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()}

type This struct {
	*Node
}

type ThisType struct {
	*Node
}

type ThrowStmt struct {
	*Node
}

func (n ThrowStmt) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type TryStmt struct {
	*Node
}

func (n TryStmt) Block() Block {
	return Block{n.Child(selector.Block)}
}

func (n TryStmt) Catch() (Catch, bool) {
	field := Catch{n.Child(selector.Catch)}
	return field, field.IsValid()}

func (n TryStmt) Finally() (Finally, bool) {
	field := Finally{n.Child(selector.Finally)}
	return field, field.IsValid()}

type TsAmbientBinding struct {
	*Node
}

func (n TsAmbientBinding) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TsAmbientBinding) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n TsAmbientBinding) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()}

type TsAmbientClass struct {
	*Node
}

func (n TsAmbientClass) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Modifier))
	}
	return ret
}

func (n TsAmbientClass) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TsAmbientClass) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n TsAmbientClass) Extends() (Extends, bool) {
	field := Extends{n.Child(selector.Extends)}
	return field, field.IsValid()}

func (n TsAmbientClass) TsImplementsClause() (TsImplementsClause, bool) {
	field := TsImplementsClause{n.Child(selector.TsImplementsClause)}
	return field, field.IsValid()}

func (n TsAmbientClass) ClassBody() ClassBody {
	return ClassBody{n.Child(selector.ClassBody)}
}

type TsAmbientEnum struct {
	*Node
}

func (n TsAmbientEnum) TsConst() (TsConst, bool) {
	field := TsConst{n.Child(selector.TsConst)}
	return field, field.IsValid()}

func (n TsAmbientEnum) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TsAmbientEnum) TsEnumBody() TsEnumBody {
	return TsEnumBody{n.Child(selector.TsEnumBody)}
}

type TsAmbientExportDecl struct {
	*Node
}

func (n TsAmbientExportDecl) ExportClause() ExportClause {
	return ExportClause{n.Child(selector.ExportClause)}
}

type TsAmbientFunc struct {
	*Node
}

func (n TsAmbientFunc) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TsAmbientFunc) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n TsAmbientFunc) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n TsAmbientFunc) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

type TsAmbientGlobal struct {
	*Node
}

func (n TsAmbientGlobal) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var ret = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(ModuleItem))
	}
	return ret
}

type TsAmbientImportAlias struct {
	*Node
}

func (n TsAmbientImportAlias) TsImportAliasDecl() TsImportAliasDecl {
	return TsImportAliasDecl{n.Child(selector.TsImportAliasDecl)}
}

type TsAmbientInterface struct {
	*Node
}

func (n TsAmbientInterface) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(Modifier))
	}
	return ret
}

func (n TsAmbientInterface) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TsAmbientInterface) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n TsAmbientInterface) TsInterfaceExtends() (TsInterfaceExtends, bool) {
	field := TsInterfaceExtends{n.Child(selector.TsInterfaceExtends)}
	return field, field.IsValid()}

func (n TsAmbientInterface) ObjectType() ObjectType {
	return ObjectType{n.Child(selector.ObjectType)}
}

type TsAmbientModule struct {
	*Node
}

func (n TsAmbientModule) NameIdent() []NameIdent {
	nodes := n.Children(selector.NameIdent)
	var ret = make([]NameIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, NameIdent{node})
	}
	return ret
}

func (n TsAmbientModule) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var ret = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(ModuleItem))
	}
	return ret
}

type TsAmbientNamespace struct {
	*Node
}

func (n TsAmbientNamespace) NameIdent() []NameIdent {
	nodes := n.Children(selector.NameIdent)
	var ret = make([]NameIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, NameIdent{node})
	}
	return ret
}

func (n TsAmbientNamespace) TsAmbientElement() []TsAmbientElement {
	nodes := n.Children(selector.TsAmbientElement)
	var ret = make([]TsAmbientElement, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(TsAmbientElement))
	}
	return ret
}

type TsAmbientTypeAlias struct {
	*Node
}

func (n TsAmbientTypeAlias) TypeAliasDecl() TypeAliasDecl {
	return TypeAliasDecl{n.Child(selector.TypeAliasDecl)}
}

type TsAmbientVar struct {
	*Node
}

func (n TsAmbientVar) LetOrConst() (LetOrConst, bool) {
	field := LetOrConst{n.Child(selector.LetOrConst)}
	return field, field.IsValid()}

func (n TsAmbientVar) Var() (Var, bool) {
	field := Var{n.Child(selector.Var)}
	return field, field.IsValid()}

func (n TsAmbientVar) TsAmbientBinding() []TsAmbientBinding {
	nodes := n.Children(selector.TsAmbientBinding)
	var ret = make([]TsAmbientBinding, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TsAmbientBinding{node})
	}
	return ret
}

type TsAsConstExpr struct {
	*Node
}

func (n TsAsConstExpr) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n TsAsConstExpr) TsConst() TsConst {
	return TsConst{n.Child(selector.TsConst)}
}

type TsAsExpr struct {
	*Node
}

func (n TsAsExpr) Left() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n TsAsExpr) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

type TsCastExpr struct {
	*Node
}

func (n TsCastExpr) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

func (n TsCastExpr) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type TsConditional struct {
	*Node
}

func (n TsConditional) Check() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

func (n TsConditional) Ext() TsType {
	return ToTsNode(n.Child(selector.TsType).Next(selector.TsType)).(TsType)
}

func (n TsConditional) Truet() TsType {
	return ToTsNode(n.Child(selector.TsType).Next(selector.TsType).Next(selector.TsType)).(TsType)
}

func (n TsConditional) Falset() TsType {
	return ToTsNode(n.Child(selector.TsType).Next(selector.TsType).Next(selector.TsType).Next(selector.TsType)).(TsType)
}

type TsConst struct {
	*Node
}

type TsDynamicImport struct {
	*Node
}

func (n TsDynamicImport) Arguments() Arguments {
	return Arguments{n.Child(selector.Arguments)}
}

type TsEnum struct {
	*Node
}

func (n TsEnum) TsConst() (TsConst, bool) {
	field := TsConst{n.Child(selector.TsConst)}
	return field, field.IsValid()}

func (n TsEnum) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TsEnum) TsEnumBody() TsEnumBody {
	return TsEnumBody{n.Child(selector.TsEnumBody)}
}

type TsEnumBody struct {
	*Node
}

func (n TsEnumBody) TsEnumMember() []TsEnumMember {
	nodes := n.Children(selector.TsEnumMember)
	var ret = make([]TsEnumMember, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TsEnumMember{node})
	}
	return ret
}

type TsEnumMember struct {
	*Node
}

func (n TsEnumMember) PropertyName() PropertyName {
	return ToTsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n TsEnumMember) Expr() (Expr, bool) {
	field := ToTsNode(n.Child(selector.Expr)).(Expr)
	return field, field.TsNode() != nil}

type TsExclToken struct {
	*Node
}

type TsExport struct {
	*Node
}

type TsExportAssignment struct {
	*Node
}

func (n TsExportAssignment) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type TsImplementsClause struct {
	*Node
}

func (n TsImplementsClause) TypeReference() []TypeReference {
	nodes := n.Children(selector.TypeReference)
	var ret = make([]TypeReference, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TypeReference{node})
	}
	return ret
}

type TsImportAliasDecl struct {
	*Node
}

func (n TsImportAliasDecl) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TsImportAliasDecl) Ref() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

type TsImportRequireDecl struct {
	*Node
}

func (n TsImportRequireDecl) TsExport() (TsExport, bool) {
	field := TsExport{n.Child(selector.TsExport)}
	return field, field.IsValid()}

func (n TsImportRequireDecl) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

type TsIndexMemberDecl struct {
	*Node
}

func (n TsIndexMemberDecl) IndexSignature() IndexSignature {
	return IndexSignature{n.Child(selector.IndexSignature)}
}

type TsInterface struct {
	*Node
}

func (n TsInterface) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TsInterface) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n TsInterface) TsInterfaceExtends() (TsInterfaceExtends, bool) {
	field := TsInterfaceExtends{n.Child(selector.TsInterfaceExtends)}
	return field, field.IsValid()}

func (n TsInterface) ObjectType() ObjectType {
	return ObjectType{n.Child(selector.ObjectType)}
}

type TsInterfaceExtends struct {
	*Node
}

func (n TsInterfaceExtends) TypeReference() []TypeReference {
	nodes := n.Children(selector.TypeReference)
	var ret = make([]TypeReference, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TypeReference{node})
	}
	return ret
}

type TsNamespace struct {
	*Node
}

func (n TsNamespace) NameIdent() []NameIdent {
	nodes := n.Children(selector.NameIdent)
	var ret = make([]NameIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, NameIdent{node})
	}
	return ret
}

func (n TsNamespace) TsNamespaceBody() TsNamespaceBody {
	return TsNamespaceBody{n.Child(selector.TsNamespaceBody)}
}

type TsNamespaceBody struct {
	*Node
}

func (n TsNamespaceBody) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var ret = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(ModuleItem))
	}
	return ret
}

type TsNamespaceExportDecl struct {
	*Node
}

func (n TsNamespaceExportDecl) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

type TsNonNull struct {
	*Node
}

func (n TsNonNull) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type TsThisParameter struct {
	*Node
}

func (n TsThisParameter) TypeAnnotation() TypeAnnotation {
	return TypeAnnotation{n.Child(selector.TypeAnnotation)}
}

type TsTypeOnly struct {
	*Node
}

type TupleType struct {
	*Node
}

func (n TupleType) TsType() []TsType {
	nodes := n.Children(selector.TsType)
	var ret = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(TsType))
	}
	return ret
}

type TypeAliasDecl struct {
	*Node
}

func (n TypeAliasDecl) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TypeAliasDecl) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()}

func (n TypeAliasDecl) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

type TypeAnnotation struct {
	*Node
}

func (n TypeAnnotation) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

type TypeArguments struct {
	*Node
}

func (n TypeArguments) TsType() []TsType {
	nodes := n.Children(selector.TsType)
	var ret = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(TsType))
	}
	return ret
}

type TypeConstraint struct {
	*Node
}

func (n TypeConstraint) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

type TypeName struct {
	*Node
}

func (n TypeName) Ref() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

type TypeParameter struct {
	*Node
}

func (n TypeParameter) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TypeParameter) TypeConstraint() (TypeConstraint, bool) {
	field := TypeConstraint{n.Child(selector.TypeConstraint)}
	return field, field.IsValid()}

func (n TypeParameter) TsType() (TsType, bool) {
	field := ToTsNode(n.Child(selector.TsType)).(TsType)
	return field, field.TsNode() != nil}

type TypeParameters struct {
	*Node
}

func (n TypeParameters) TypeParameter() []TypeParameter {
	nodes := n.Children(selector.TypeParameter)
	var ret = make([]TypeParameter, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TypeParameter{node})
	}
	return ret
}

type TypePredicate struct {
	*Node
}

func (n TypePredicate) Paramref() ReferenceIdent {
	return ReferenceIdent{n.Child(selector.ReferenceIdent)}
}

func (n TypePredicate) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

type TypeQuery struct {
	*Node
}

func (n TypeQuery) ReferenceIdent() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

type TypeReference struct {
	*Node
}

func (n TypeReference) TypeName() TypeName {
	return TypeName{n.Child(selector.TypeName)}
}

func (n TypeReference) TypeArguments() (TypeArguments, bool) {
	field := TypeArguments{n.Child(selector.TypeArguments)}
	return field, field.IsValid()}

type TypeVar struct {
	*Node
}

func (n TypeVar) ReferenceIdent() ReferenceIdent {
	return ReferenceIdent{n.Child(selector.ReferenceIdent)}
}

type UnaryExpr struct {
	*Node
}

func (n UnaryExpr) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

type UnionType struct {
	*Node
}

func (n UnionType) Inner() []TsType {
	nodes := n.Children(selector.TsType)
	var ret = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToTsNode(node).(TsType))
	}
	return ret
}

type UniqueType struct {
	*Node
}

func (n UniqueType) TsType() TsType {
	return ToTsNode(n.Child(selector.TsType)).(TsType)
}

type Var struct {
	*Node
}

type VarDecl struct {
	*Node
}

func (n VarDecl) BindingPattern() (BindingPattern, bool) {
	field := ToTsNode(n.Child(selector.BindingPattern)).(BindingPattern)
	return field, field.TsNode() != nil}

func (n VarDecl) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()}

func (n VarDecl) TsExclToken() (TsExclToken, bool) {
	field := TsExclToken{n.Child(selector.TsExclToken)}
	return field, field.IsValid()}

func (n VarDecl) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()}

func (n VarDecl) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()}

type VarStmt struct {
	*Node
}

func (n VarStmt) VarDecl() []VarDecl {
	nodes := n.Children(selector.VarDecl)
	var ret = make([]VarDecl, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, VarDecl{node})
	}
	return ret
}

type WhileStmt struct {
	*Node
}

func (n WhileStmt) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n WhileStmt) Stmt() Stmt {
	return ToTsNode(n.Child(selector.Stmt)).(Stmt)
}

type WithStmt struct {
	*Node
}

func (n WithStmt) Expr() Expr {
	return ToTsNode(n.Child(selector.Expr)).(Expr)
}

func (n WithStmt) Stmt() Stmt {
	return ToTsNode(n.Child(selector.Stmt)).(Stmt)
}

type Yield struct {
	*Node
}

func (n Yield) Expr() (Expr, bool) {
	field := ToTsNode(n.Child(selector.Expr)).(Expr)
	return field, field.TsNode() != nil}


